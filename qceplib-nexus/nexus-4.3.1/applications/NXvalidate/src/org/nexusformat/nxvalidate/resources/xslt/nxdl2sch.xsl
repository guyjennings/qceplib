<?xml version="1.0" encoding="UTF-8"?>

<!--
    ########### SVN repository information ###################
    # $LastChangedDate: 2010-10-07 05:35:23 +0100 (Thu, 07 Oct 2010) $
    # $LastChangedBy: Freddie Akeroyd $
    # $LastChangedRevision: 601 $
    # $HeadURL: http://svn.nexusformat.org/definitions/trunk/xslt/nxdl2sch.xsl $
    ########### SVN repository information ###################
    
    Purpose:
    This stylesheet is used to translate the NeXus Definition Language
    specifications into Schematron Schema (.sch) files for use in
    validating candidate NeXus data files.
    
    Usage (for example NXsource class):
    xsltproc nxdl2sch.xsl NXsource.nxdl.xml > NXsource.sch
-->

<!-- 
    This stylesheet automatically add the contents of nexus_base.sch to the final output
-->

<xsl:stylesheet
    version="1.0"
    xmlns:nxdl="http://definition.nexusformat.org/nxdl/3.1"
    xmlns:nxsd="http://definition.nexusformat.org/schema/3.1"
    xmlns:sch="http://purl.oclc.org/dsdl/schematron"
    xmlns:xs="http://www.w3.org/2001/XMLSchema"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
    
    <xsl:output method="xml" indent="yes" version="1.0" encoding="UTF-8"/>
    
    <xsl:template match="/">
        <xsl:comment>Generated by $Id: nxdl2sch.xsl 601 2010-10-07 04:35:23Z Freddie Akeroyd $</xsl:comment>
        
        <xsl:element name="sch:schema">
            <xsl:attribute name="queryBinding">xslt2</xsl:attribute>
            <xsl:element name="sch:ns">
                <xsl:attribute name="uri">http://www.w3.org/1999/XSL/Transform</xsl:attribute>
                <xsl:attribute name="prefix">xsl</xsl:attribute>
            </xsl:element>
            <xsl:element name="sch:ns">
                <xsl:attribute name="uri">http://definition.nexusformat.org/schema/3.1</xsl:attribute>
                <xsl:attribute name="prefix">nx</xsl:attribute>
            </xsl:element>
            <xsl:element name="sch:ns">
                <xsl:attribute name="uri">http://www.w3.org/2001/XMLSchema-instance</xsl:attribute>
                <xsl:attribute name="prefix">xsi</xsl:attribute>
            </xsl:element>
            
            <!-- include nexus_base.sch -->
            <xsl:comment> BEGIN include of nexus_base.sch </xsl:comment>
            <xsl:apply-templates select="document('')//sch:schema/*" />
            <xsl:comment> END include of nexus_base.sch </xsl:comment>
            
            <xsl:apply-templates select="*"/>
            </xsl:element>
    </xsl:template>
    
    <!-- handle include of nexus_base.sch -->
    <xsl:template match="//sch:schema//*">
            <xsl:copy>
                <xsl:copy-of select="@*" />
                <xsl:apply-templates />
            </xsl:copy>
    </xsl:template>
        
    <xsl:template match="nxdl:definition">
        <xsl:variable name="svnid" select="@svnid" />
        <xsl:comment>Processing <xsl:value-of select="$svnid"/></xsl:comment>
        <xsl:variable name="mycontext">
            <xsl:choose>
                <xsl:when test="@restricts">nx:<xsl:value-of select="@restricts"/>[@xsi:type='<xsl:value-of select="@name"/>']</xsl:when>
                <xsl:otherwise>nx:<xsl:value-of select="@name"/></xsl:otherwise>
            </xsl:choose>
        </xsl:variable>
        <xsl:element name="sch:pattern">
                <xsl:attribute name="fpi">
                    <xsl:value-of select="name()"/>: <xsl:value-of select="@name"
                    /> fields</xsl:attribute>
                <xsl:element name="sch:rule">
                        
                    <xsl:attribute name="context">//<xsl:value-of 
                        select="$mycontext"/>/*[count(child::*) = 0]</xsl:attribute>
                    <xsl:element name="sch:let">
                        <xsl:attribute name="name">fields</xsl:attribute>
                        <xsl:attribute name="value">(<xsl:for-each 
                            select="nxdl:field"><xsl:if 
                                test="position()>1">,</xsl:if>'<xsl:value-of 
                                    select="@name"/>'</xsl:for-each>)</xsl:attribute>
                    </xsl:element>
                    <xsl:if test="not(@restricts)">
                      <xsl:element name="sch:report">
                        <xsl:attribute name="test">count(index-of($fields,name()))=0</xsl:attribute>                        
                        Non-standard field <sch:value-of select="name()"/> in <sch:value-of select="name(..)"/> 
                      </xsl:element>
                    </xsl:if>
                </xsl:element>
            </xsl:element>
            <xsl:element name="sch:pattern">
                <xsl:attribute name="fpi">
                    <xsl:value-of select="name()"/>: <xsl:value-of select="@name"
                    /> groups</xsl:attribute>
                <xsl:element name="sch:rule">
                    <!-- Groups always have child nodes.  Easy to find them. -->
                    <xsl:attribute name="context">//<xsl:value-of 
                        select="$mycontext"/>/*[count(child::*) > 0]</xsl:attribute>
                    <!--
                        The test for groups is a bit more complicated.  Example:
                        In NXDL, name() = 'group', @type='NXsource', @name="second" (and is optional)
                        Build a list of NXsource/* or NXsource/second
                    -->
                    <xsl:element name="sch:let">
                        <xsl:attribute name="name">group_types</xsl:attribute>
                        <xsl:attribute name="value">(<xsl:for-each 
                            select="nxdl:group"><xsl:if 
                                test="position()>1">,</xsl:if>'<xsl:value-of 
                                    select="@type"/>'</xsl:for-each>)</xsl:attribute>
                    </xsl:element>
                    
                    <xsl:if test="not(@restricts)">  
                      <xsl:element name="sch:report">
                        <xsl:attribute name="test">count(index-of($group_types,name()))=0</xsl:attribute>                        
                        Non-standard group in: 
                        <xsl:element name="sch:value-of">
                            <xsl:attribute name="select">name()</xsl:attribute>
                        </xsl:element>[<xsl:element name="sch:value-of">
                            <xsl:attribute name="select">@name</xsl:attribute>
                        </xsl:element>]
                      </xsl:element>
                    </xsl:if>
                </xsl:element>
            </xsl:element>
            <xsl:apply-templates select="nxdl:field|nxdl:group">
                <xsl:with-param name="restricts" select="@restricts"></xsl:with-param>
                <xsl:with-param name="context" select="$mycontext"></xsl:with-param>
            </xsl:apply-templates>
    </xsl:template>
    
    <xsl:template match="nxdl:field">
        <xsl:param name="restricts" />
        <xsl:param name="context" />
        <xsl:text>
        </xsl:text>
        <xsl:element name="sch:pattern">
            <xsl:attribute name="fpi">
                <xsl:value-of select="$context"/>/<xsl:value-of select="@name"/>
            </xsl:attribute>
            <xsl:if test="$restricts">
                <xsl:element name="sch:rule">
                    <xsl:attribute name="context">//<xsl:value-of select="$context"/></xsl:attribute>
                    <xsl:element name="sch:assert">
                        <xsl:attribute name="test">nx:<xsl:value-of select="@name"/></xsl:attribute>                        
                        Missing field '<xsl:value-of select="@name"/>' in <sch:value-of select="name()"/>
                    </xsl:element> 
                </xsl:element>
            </xsl:if>
            <xsl:element name="sch:rule">
                <xsl:attribute name="context">//<xsl:value-of select="$context"/>/nx:<xsl:value-of 
                        select="@name"/></xsl:attribute>
                <xsl:comment> sch:extends  check NAPItype attribute value (syntax is already checked) </xsl:comment>
                <!-- assume that the converted files will supply all defaults -->
                <xsl:element name="sch:assert">
                    <xsl:variable name="ntype">
                      <xsl:choose>
                        <xsl:when test="@type"><xsl:value-of select="@type"/></xsl:when>
                        <xsl:otherwise>NX_CHAR</xsl:otherwise>
                      </xsl:choose>                        
                    </xsl:variable>
                    <xsl:variable name="valid_types">
                        <xsl:call-template name="translate_type">
                            <xsl:with-param name="type" select="$ntype"/>
                        </xsl:call-template>
                    </xsl:variable>
                    <xsl:attribute name="test">count(index-of(<xsl:value-of select="$valid_types"/>,tokenize(@NAPItype,'\[')[1] )) = 1</xsl:attribute>
                    NAPItype must be one of <xsl:value-of select="$valid_types"/> for '<xsl:value-of select="@name"/>'
                </xsl:element>
            </xsl:element>
        </xsl:element>
        <!-- handle enumerations -->
        <xsl:if test="nxdl:enumeration">
            <xsl:element name="sch:pattern">
                <xsl:attribute name="fpi">
                    <xsl:value-of select="$context"/>/<xsl:value-of 
                        select="@name"/>_enumeration</xsl:attribute>
                <xsl:comment> check value against enumeration </xsl:comment>
                <xsl:variable name="enum_name">enumeration</xsl:variable>
                <xsl:element name="sch:rule">
                    <xsl:attribute name="context">//<xsl:value-of 
                        select="$context"/>/nx:<xsl:value-of 
                            select="@name"/></xsl:attribute>
                    <xsl:element name="sch:let">
                        <xsl:attribute name="name">enumeration</xsl:attribute>
                        <xsl:attribute name="value">(<xsl:for-each 
                            select="nxdl:enumeration/nxdl:item"><xsl:if 
                                test="position()>1">,</xsl:if>'<xsl:value-of 
                                    select="@value"/>'</xsl:for-each>)</xsl:attribute>
                    </xsl:element>
                    <xsl:element name="sch:assert">
                        <xsl:attribute name="test">count(index-of($enumeration,.))=1</xsl:attribute>
                        type 
                        <xsl:element name="sch:value-of">
                            <xsl:attribute name="select">.</xsl:attribute>
                        </xsl:element>
                        must be one of 
                        <xsl:element name="sch:value-of">
                            <xsl:attribute name="select">$enumeration</xsl:attribute>
                        </xsl:element>
                    </xsl:element>
                </xsl:element>
            </xsl:element>
        </xsl:if>
    </xsl:template>
    
    <xsl:template match="nxdl:group">
        <xsl:param name="restricts" />
        <xsl:param name="context" />
        <xsl:comment>::<xsl:value-of select="name()"/>::<xsl:value-of 
                select="@type"/><xsl:if 
                    test="count(@name)>0">[<xsl:value-of 
                        select="@name"/>]</xsl:if>::</xsl:comment>
        <xsl:if test="$restricts">
            <xsl:element name="sch:pattern">
                <xsl:attribute name="fpi">
                    <xsl:value-of select="$context"/>/<xsl:value-of select="@name"/>
                </xsl:attribute>
                <xsl:element name="sch:rule">
                <xsl:attribute name="context">//<xsl:value-of select="$context"/></xsl:attribute>
                <xsl:element name="sch:assert">
                    <xsl:attribute name="test">nx:<xsl:value-of select="@type"/></xsl:attribute>                        
                    Missing group '<xsl:value-of select="@type"/>' in <sch:value-of select="name()"/>
                </xsl:element> 
                </xsl:element>
            </xsl:element>
        </xsl:if>
        <xsl:variable name="mycontext">
            <xsl:value-of select="$context"/>/nx:<xsl:value-of select="@type"/>
            <xsl:if test="@name">[@name='<xsl:value-of select="@name"/>']</xsl:if>
        </xsl:variable>        
        <xsl:apply-templates select="nxdl:field|nxdl:group">
            <xsl:with-param name="restricts" select="$restricts"></xsl:with-param>
            <xsl:with-param name="context" select="$mycontext"></xsl:with-param>
        </xsl:apply-templates>
        
    </xsl:template>
    
    <!-- return a sequence of valid types for an NXDL type -->
    <xsl:template name="translate_type">
        <xsl:param name="type" select="NX_CHAR"/>
        <xsl:variable name="posints">'NX_UINT8','NX_UINT16','NX_UINT32','NX_UINT64'</xsl:variable>
        <xsl:variable name="ints"><xsl:value-of select="$posints"/>,'NX_INT8','NX_INT16','NX_INT32','NX_INT64'</xsl:variable>
        <xsl:variable name="floats">'NX_FLOAT32','NX_FLOAT64'</xsl:variable>
        <xsl:variable name="numbers"><xsl:value-of select="$ints"/>,<xsl:value-of select="$floats"/></xsl:variable>
        <xsl:choose>
            <xsl:when test="$type = 'NX_NUMBER'">(<xsl:value-of select="$numbers"/>)</xsl:when>
            <xsl:when test="$type = 'NX_FLOAT'">(<xsl:value-of select="$floats"/>)</xsl:when>
            <xsl:when test="$type = 'NX_INT'">(<xsl:value-of select="$ints"/>)</xsl:when>
            <xsl:when test="$type = 'NX_UINT'">(<xsl:value-of select="$posints"/>)</xsl:when>
            <xsl:when test="$type = 'NX_DATE_TIME'">('NX_CHAR')</xsl:when>
            <xsl:when test="$type = 'ISO8601'">('NX_CHAR')</xsl:when>
            <xsl:otherwise>('<xsl:value-of select="$type"/>')</xsl:otherwise>
        </xsl:choose>
    </xsl:template>

    <!-- return type string before any [ -->
    <xsl:template name="get_type">
        <xsl:param name="type" select="NX_CHAR"/>
        <xsl:variable name="mat" select="substring-before($type, '[')"/>
        <xsl:choose>
            <xsl:when test="$mat"><xsl:value-of select="$mat"/></xsl:when>
            <xsl:otherwise><xsl:value-of select="$type"/></xsl:otherwise>
        </xsl:choose>
    </xsl:template>


    <!-- original nexus_base.sch to be included via code above in each output file -->   
    <sch:schema 
        xmlns:sch="http://purl.oclc.org/dsdl/schematron" 
        xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
        queryBinding="xslt2">
        
        <!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
        <!-- This file is automatically included in the final all.sch -->
        <!-- by the nxdl2sch.xsl transform                            -->
        <!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
        
        <sch:ns uri="http://definition.nexusformat.org/schema/3.1" prefix="nx"/>
        <sch:ns uri="http://www.w3.org/1999/XSL/Transform" prefix="xsl"/>
        <sch:ns uri="http://www.w3.org/2001/XMLSchema-instance" prefix="xsi" />
        
        <xsl:key name="targets" match="//*[not(name()='NAPIlink')]" use="@target" />
        
        <!-- ++++++++++++++++++++++++++++++++++++++ -->
        <!-- defined variables -->
        <!-- ++++++++++++++++++++++++++++++++++++++ -->
        
        <sch:let name="NAPItype_INT" value="'NX_INT(8|16|32|64)'"/>
        <sch:let name="NAPItype_FLOAT" value="'NX_FLOAT(32|64)'"/>
        <sch:let name="ARRAY_regexp" value="'(\[0-9\])?'"/> <!-- this is not complete -->
        <sch:let name="NAPItype_regexp" 
            value="concat('NX_CHAR|',$NAPItype_INT,'|',$NAPItype_FLOAT)"/>
        
        <sch:let name="ValidItemName_regexp" value="'^[A-Za-z_][A-Za-z0-9_]*$'" />
        <sch:let name="ValidNXClassName_regexp" value="'^NX[A-Za-z0-9_]*$'" />
        
        <!-- ++++++++++++++++++++++++++++++++++++++ -->
        <!-- abstract rules -->
        <!-- ++++++++++++++++++++++++++++++++++++++ -->
        
        <sch:pattern fpi="check for name attributes">
            <sch:rule abstract="true" id="rule_check_NXclass">
                <!-- ensure group type (NeXus class) is valid  -->
                <sch:assert 
                    test="matches(name(),$ValidNXClassName_regexp)"
                    diagnostics="diag_NXclass_needs_valid_name"
                />
                <!-- ensure NXclass groups have a valid @name -->
                <sch:assert 
                    diagnostics="diag_NXclass_needs_name_attr"
                    test="matches(@name,$ValidItemName_regexp)"
                />
            </sch:rule>
        </sch:pattern>
        
        <sch:pattern fpi="check NAPIlink element">
            <sch:rule abstract="true" id="rule_check_NAPIlink_element">
                <sch:assert 
                    diagnostics="diag_NAPIlink_needs_target_attr" 
                    test="@target"/>
            </sch:rule>
        </sch:pattern>
        
        <sch:pattern fpi="check NAPItype attributes">
            <sch:rule abstract="true" id="rule_check_NAPItype_attribute">
                <!--<sch:report test="true()">
                    ::<sch:value-of select="name(..)"/>/@<sch:value-of select="name()"/>::
                    </sch:report>-->
                <!-- NAPItype MUST start with "NX_" -->
                <sch:assert test="starts-with(@NAPItype,'NX_')"
                    >NAPItype value should start with 'NX_'.</sch:assert>
                <sch:assert test="matches(@NAPItype,$NAPItype_regexp)">
                    NAPItype attribute must be one of the allowed data types.
                    Value '<sch:value-of select="@NAPItype"/>' was found in 
                    <sch:value-of select="name()"/>.
                </sch:assert>
            </sch:rule>
            <sch:rule abstract="true" id="rule_check_field">
                <sch:extends rule="rule_check_NAPItype_attribute"/>
                <sch:assert test="matches(name(),$ValidItemName_regexp)">
                    Field name <sch:value-of select="name()"/> contains invalid characters.
                </sch:assert>
            </sch:rule>
            <sch:rule abstract="true" id="rule_check_group">
                <sch:extends rule="rule_check_NXclass"/>
            </sch:rule>
        </sch:pattern>
        
        <!-- ++++++++++++++++++++++++++++++++++++++ -->
        <!-- diagnostics -->
        <!-- ++++++++++++++++++++++++++++++++++++++ -->
        
        <sch:diagnostics>
            <sch:diagnostic id="diag_NXclass_needs_name_attr"
                ><sch:value-of select="name()"
                />: <sch:value-of select="@name"/> is invalid for name="" attribute</sch:diagnostic>
            <sch:diagnostic id="diag_NXclass_needs_valid_name"
                ><sch:value-of select="name()"
                />: An NX... group must have a valid name</sch:diagnostic>
            <sch:diagnostic id="diag_NAPIlink_needs_target_attr"
                ><sch:value-of select="name(../@name)"
                />[<sch:value-of select="name(..)"/>]: 
                A NAPIlink element must have a target="" attribute.</sch:diagnostic>
        </sch:diagnostics>
        
        <!-- ++++++++++++++++++++++++++++++++++++++ -->
        <!-- patterns to match nodes in instance document -->
        <!-- ++++++++++++++++++++++++++++++++++++++ -->
        
        <sch:pattern>
            <sch:rule context="/nx:NXroot//*[count(child::*) > 0]">
                <sch:extends rule="rule_check_NXclass"/>
            </sch:rule>
        </sch:pattern>
        
        <sch:pattern>
            <sch:rule context="//nx:NAPIlink">
                <sch:extends rule="rule_check_NAPIlink_element"/>
                <!--
                    Evaluate each NAPIlink element to verify that its @target 
                    attribute points to one and only one data elements (field 
                    that is not NAPIlink) with the same attribute and value.
                    This does not evaluate if the value of the target (a path in the 
                    NXentry) is correct.  That will come.
                -->
                <sch:let name="t" value="count(key('targets',@target))"/>
                <sch:assert test="$t > 0">Target not found in file</sch:assert>
                <sch:assert test="$t &lt;= 1">Multiple targets found in file</sch:assert>
            </sch:rule>
        </sch:pattern>
        
        <sch:pattern>
            <sch:rule context="/nx:NXroot//*[count(child::*) = 0 and not(name() = 'NAPIlink')]">
                <sch:extends rule="rule_check_field"/>
            </sch:rule>
        </sch:pattern>
        
    </sch:schema>
    
</xsl:stylesheet>
